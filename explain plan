CREATE OR REPLACE FUNCTION sp_insert_audit_master() RETURNS VOID AS $$
BEGIN
  PERFORM sp_data_arc_log('Start of audit master insert');

  INSERT INTO batch_audit_master
    (seq_audit_id, application_id, process_name, status, insert_datetime, insert_process, insert_user, plan_name)
  SELECT g_seq_audit_id,
         ba.application_id,
         c_process,
         c_running_status,
         NOW(),
         c_process,
         CURRENT_USER,
         g_plan_name
    FROM batch_application ba
   WHERE ba.application_name = c_application;

  PERFORM sp_data_arc_log('End of audit master insert');
END;
$$ LANGUAGE plpgsql;
--------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sp_select_golive_date() RETURNS VOID AS $$
BEGIN
  -- Select the minimum go-live date and store it in the global variable
  SELECT MIN(golive_date)
    INTO g_go_live_date
    FROM ram_revenue_stream_history
   WHERE plan_name = g_plan_name
     AND data_archival_flag = 'Y'
     AND data_arc_back_in_months IS NOT NULL;

  -- Log the selected go-live date
  PERFORM sp_data_arc_log('Selected golive date: ' || g_go_live_date::TEXT);
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------
CREATE OR REPLACE FUNCTION sp_data_archival(
  p_plan_name VARCHAR,
  p_seq_revenue_id NUMERIC,
  p_seq_audit_id NUMERIC
) RETURNS VOID AS $$
BEGIN
  -- Assign parameters to global variables
  g_plan_name := p_plan_name;
  g_seq_revenue_id := p_seq_revenue_id;
  g_seq_audit_id := p_seq_audit_id;

  -- Delete existing logs and initialize archival process
  PERFORM sp_dbmslog_del();
  PERFORM sp_data_arc_log('Start of data archival');

  -- Insert audit record and select the go-live date
  PERFORM sp_insert_audit_master();
  PERFORM sp_select_golive_date();
  PERFORM sp_data_arc_log('New golive date :: ' || g_go_live_date::TEXT);

  -- Perform archival operations if a go-live date is determined
  IF g_go_live_date IS NOT NULL THEN
    PERFORM sp_move_inv_dtl_data_to_hist();
    PERFORM sp_move_inv_arc_data_to_hist();
    PERFORM sp_move_pay_dtl_data_to_hist();
    PERFORM sp_move_pay_arc_data_to_hist();
    PERFORM sp_move_pay_stg_data_to_hist();
    PERFORM sp_move_pay_supp_data_to_hist();
    PERFORM sp_move_rec_dtl_data_to_hist();
    PERFORM sp_move_rec_arc_data_to_hist();
    PERFORM sp_revenue_stream_update();
    PERFORM sp_insert_alert();
  END IF;

  -- Log completion of the archival process
  PERFORM sp_data_arc_log('End of data archival');
END;
$$ LANGUAGE plpgsql;
---------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sp_revenue_stream_update() RETURNS VOID AS $$
BEGIN
  PERFORM sp_data_arc_log('Start of revenue stream update');

  -- Update the revenue stream table
  UPDATE ram_revenue_stream
     SET golive_date = g_go_live_date
   WHERE plan_name = g_plan_name
     AND (seq_revenue_id = g_seq_revenue_id OR base_seq_revenue_id = g_seq_revenue_id);

  -- Update the revenue stream history table
  UPDATE ram_revenue_stream_history
     SET golive_date = g_go_live_date
   WHERE plan_name = g_plan_name
     AND (seq_revenue_id = g_seq_revenue_id OR base_seq_revenue_id = g_seq_revenue_id);

  PERFORM sp_data_arc_log('End of revenue stream update');
END;
---------------------------------------
CREATE OR REPLACE FUNCTION sp_move_rec_dtl_data_to_hist() RETURNS VOID AS $$
DECLARE
  v_tbl_rowid UUID[]; -- Replace UUID with the primary key type of ram_recon_detail
BEGIN
  PERFORM sp_data_arc_log('Start of reconciliation detail data archival to history table');

  -- Fetch row IDs matching the criteria in batches
  FOR v_tbl_rowid IN
    SELECT id -- Replace "id" with the primary key of ram_recon_detail
    FROM ram_recon_detail
    WHERE reconciliation_date < g_go_live_date
      AND plan_name = g_plan_name
      AND seq_revenue_id IN
          (SELECT seq_revenue_id
             FROM ram_revenue_stream
            WHERE plan_name = g_plan_name
              AND seq_revenue_id = g_seq_revenue_id)
  LOOP
    -- Move data to the reconciliation detail history table
    INSERT INTO ram_recon_detail_history
    SELECT *
      FROM ram_recon_detail
     WHERE id = v_tbl_rowid;

    -- Delete data from the reconciliation detail table
    DELETE FROM ram_recon_detail
     WHERE id = v_tbl_rowid;
  END LOOP;

  PERFORM sp_data_arc_log('End of reconciliation detail data archival to history table');
END;
$$ LANGUAGE plpgsql;
------------------------------------
CREATE OR REPLACE FUNCTION sp_move_rec_arc_data_to_hist() RETURNS VOID AS $$
DECLARE
  v_tbl_rowid UUID[]; -- Replace UUID with the primary key type of ram_recon_archive
BEGIN
  PERFORM sp_data_arc_log('Start of reconciliation archival from archive to history table');

  -- Fetch row IDs matching the criteria in batches
  FOR v_tbl_rowid IN
    SELECT id -- Replace "id" with the primary key of ram_recon_archive
    FROM ram_recon_archive
    WHERE reconciliation_date < g_go_live_date
      AND plan_name = g_plan_name
      AND seq_revenue_id IN
          (SELECT seq_revenue_id
             FROM ram_revenue_stream
            WHERE plan_name = g_plan_name
              AND seq_revenue_id = g_seq_revenue_id)
  LOOP
    -- Move data to the reconciliation history table
    INSERT INTO ram_recon_history
    SELECT *
      FROM ram_recon_archive
     WHERE id = v_tbl_rowid;

    -- Delete data from the reconciliation archive table
    DELETE FROM ram_recon_archive
     WHERE id = v_tbl_rowid;
  END LOOP;

  PERFORM sp_data_arc_log('End of reconciliation archival from archive to history table');
END;
$$ LANGUAGE plpgsql;
-----------------------------------------------
CREATE OR REPLACE FUNCTION sp_move_pay_supp_data_to_hist() RETURNS VOID AS $$
DECLARE
  v_tbl_rowid UUID[]; -- Replace UUID with the primary key type of ram_payment_supplementary
BEGIN
  PERFORM sp_data_arc_log('Start of payment supplementary data archival to history table');

  -- Fetch row IDs matching the criteria in batches
  FOR v_tbl_rowid IN
    SELECT id -- Replace "id" with the primary key of ram_payment_supplementary
    FROM ram_payment_supplementary
    WHERE payment_date < g_go_live_date
      AND plan_name = g_plan_name
      AND seq_revenue_id IN
          (SELECT seq_revenue_id
             FROM ram_revenue_stream
            WHERE plan_name = g_plan_name
              AND seq_revenue_id = g_seq_revenue_id)
  LOOP
    -- Move data to the payment supplementary history table
    INSERT INTO ram_payment_supplementary_history
    SELECT *
      FROM ram_payment_supplementary
     WHERE id = v_tbl_rowid;

    -- Delete data from the payment supplementary table
    DELETE FROM ram_payment_supplementary
     WHERE id = v_tbl_rowid;
  END LOOP;

  PERFORM sp_data_arc_log('End of payment supplementary data archival to history table');
END;
$$ LANGUAGE plpgsql;
------------------------------------------------------
CREATE OR REPLACE FUNCTION sp_move_pay_dtl_data_to_hist() RETURNS VOID AS $$
DECLARE
  v_tbl_rowid UUID[]; -- Replace UUID with the primary key type of ram_payment_detail
BEGIN
  PERFORM sp_data_arc_log('Start of payment data archival from detail to history table');

  -- Fetch row IDs matching the criteria in batches
  FOR v_tbl_rowid IN
    SELECT id -- Replace "id" with the primary key of ram_payment_detail
    FROM ram_payment_detail
    WHERE payment_date < g_go_live_date
      AND plan_name = g_plan_name
      AND seq_revenue_id IN
          (SELECT seq_revenue_id
             FROM ram_revenue_stream
            WHERE plan_name = g_plan_name
              AND seq_revenue_id = g_seq_revenue_id)
  LOOP
    -- Move data to the payment detail history table
    INSERT INTO ram_payment_detail_history
    SELECT *
      FROM ram_payment_detail
     WHERE id = v_tbl_rowid;

    -- Delete data from the payment detail table
    DELETE FROM ram_payment_detail
     WHERE id = v_tbl_rowid;
  END LOOP;

  PERFORM sp_data_arc_log('End of payment data archival from detail to history table');
END;
$$ LANGUAGE plpgsql;
---------------------------------------
CREATE OR REPLACE FUNCTION sp_move_pay_arc_data_to_hist() RETURNS VOID AS $$
DECLARE
  v_tbl_rowid UUID[]; -- Replace UUID with the primary key type of ram_payment_archive
  v_tbl_seq_pay_hdr_id BIGINT[]; -- Adjust based on seq_payment_header_id type
  v_tbl_seq_pay_dtl_id BIGINT[]; -- Adjust based on seq_payment_detail_id type
BEGIN
  PERFORM sp_data_arc_log('Start of payment data archival from archive to history table');

  -- Fetch row IDs, header IDs, and detail IDs in batches
  FOR v_tbl_rowid, v_tbl_seq_pay_hdr_id, v_tbl_seq_pay_dtl_id IN
    SELECT id, seq_payment_header_id, seq_payment_detail_id
    FROM ram_payment_archive
    WHERE payment_start_date < g_go_live_date
      AND plan_name = g_plan_name
      AND seq_revenue_id IN
          (SELECT seq_revenue_id
             FROM ram_revenue_stream
            WHERE plan_name = g_plan_name
              AND seq_revenue_id = g_seq_revenue_id)
  LOOP
    -- Move data to the payment history table
    INSERT INTO ram_payment_history
    SELECT *
      FROM ram_payment_archive
     WHERE id = v_tbl_rowid;

    -- Delete data from the payment archive table
    DELETE FROM ram_payment_archive
     WHERE id = v_tbl_rowid;

    -- Move supplemental data to the payment additional data history table
    INSERT INTO ram_payment_add_data_history
    SELECT *
      FROM ram_payment_additional_data
     WHERE seq_payment_header_id = v_tbl_seq_pay_hdr_id
       AND seq_payment_detail_id = v_tbl_seq_pay_dtl_id
       AND plan_name = g_plan_name;

    -- Delete data from the payment additional data table
    DELETE FROM ram_payment_additional_data
     WHERE seq_payment_header_id = v_tbl_seq_pay_hdr_id
       AND seq_payment_detail_id = v_tbl_seq_pay_dtl_id
       AND plan_name = g_plan_name;
  END LOOP;

  PERFORM sp_data_arc_log('End of payment data archival from archive to history table');
END;
$$ LANGUAGE plpgsql;
------------------------------------
CREATE OR REPLACE FUNCTION sp_move_inv_dtl_data_to_hist() RETURNS VOID AS $$
DECLARE
  v_tbl_rowid UUID[]; -- Array to store primary keys or unique identifiers
BEGIN
  PERFORM sp_data_arc_log('Start of invoice data archival from detail to history table');

  -- Fetch row IDs matching the criteria in batches
  FOR v_tbl_rowid IN
    SELECT id -- Replace "id" with the primary key of ram_invoice_detail
    FROM ram_invoice_detail
    WHERE plan_name = g_plan_name
      AND seq_invoice_header_id IN
          (SELECT seq_invoice_header_id
             FROM ram_invoice_header
            WHERE invoice_date < g_go_live_date
              AND seq_revenue_id IN
                  (SELECT seq_revenue_id
                     FROM ram_revenue_stream
                    WHERE plan_name = g_plan_name
                      AND (seq_revenue_id = g_seq_revenue_id OR
                          base_seq_revenue_id = g_seq_revenue_id)))
  LOOP
    -- Move data to the history table
    INSERT INTO ram_invoice_history
    SELECT *
      FROM ram_invoice_detail
     WHERE id = v_tbl_rowid;

    -- Delete data from the detail table
    DELETE FROM ram_invoice_detail
     WHERE id = v_tbl_rowid;
  END LOOP;

  PERFORM sp_data_arc_log('End of invoice data archival from detail to history table');
END;
$$ LANGUAGE plpgsql;
-------------------------------------
CREATE OR REPLACE FUNCTION sp_move_inv_arc_data_to_hist() RETURNS VOID AS $$
DECLARE
  v_tbl_rowid UUID[]; -- Array to store primary keys or unique identifiers
BEGIN
  PERFORM sp_data_arc_log('Start of invoice data archival from archive to history table');

  -- Fetch row IDs matching the criteria in batches
  FOR v_tbl_rowid IN
    SELECT id -- Replace "id" with the primary key of ram_invoice_archive
    FROM ram_invoice_archive
    WHERE plan_name = g_plan_name
      AND seq_invoice_header_id IN
          (SELECT seq_invoice_header_id
             FROM ram_invoice_header
            WHERE invoice_date < g_go_live_date
              AND seq_revenue_id IN
                  (SELECT seq_revenue_id
                     FROM ram_revenue_stream
                    WHERE plan_name = g_plan_name
                      AND (seq_revenue_id = g_seq_revenue_id OR
                          base_seq_revenue_id = g_seq_revenue_id)))
  LOOP
    -- Move data to the history table
    INSERT INTO ram_invoice_history
    SELECT *
      FROM ram_invoice_archive
     WHERE id = v_tbl_rowid;

    -- Delete data from the archive table
    DELETE FROM ram_invoice_archive
     WHERE id = v_tbl_rowid;
  END LOOP;

  PERFORM sp_data_arc_log('End of invoice data archival from archive to history table');
END;
$$ LANGUAGE plpgsql;
-----------------------------------------

CREATE OR REPLACE FUNCTION sp_insert_audit_master() RETURNS VOID AS $$
BEGIN
  PERFORM sp_data_arc_log('Start of audit master insert');

  INSERT INTO batch_audit_master
    (seq_audit_id, application_id, process_name, status, insert_datetime, insert_process, insert_user, plan_name)
  SELECT g_seq_audit_id,
         ba.application_id,
         c_process,
         c_running_status,
         NOW(),
         c_process,
         CURRENT_USER,
         g_plan_name
    FROM batch_application ba
   WHERE ba.application_name = c_application;

  PERFORM sp_data_arc_log('End of audit master insert');
END;
$$ LANGUAGE plpgsql;
